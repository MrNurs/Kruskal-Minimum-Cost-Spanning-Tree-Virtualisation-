<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kruskal MST Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    svg {
      width: 100%;
      height: 500px;
      border: 1px solid black;
    }
    line {
      stroke: gray;
      stroke-width: 2;
    }
    .mst {
      stroke: green;
      stroke-width: 4;
    }
    .current {
      stroke: red;
      stroke-width: 4;
    }
    circle {
      fill: steelblue;
    }
    text {
      font-size: 14px;
      text-anchor: middle;
    }
    table {
      border-collapse: collapse;
      margin-top: 10px;
    }
    td, th {
      border: 1px solid black;
      padding: 5px;
      text-align: center;
    }
  </style>
</head>
<body>
<h2>Алгоритм Крускала (MST) - Визуализация</h2>
<button onclick="generateGraph()">Создать новый граф</button>
<button onclick="startKruskalStepByStep()">Поиск MST (пошагово)</button>
<svg></svg>
<h3>Disjoint Set</h3>
<table id="disjointSet"></table>
<h3>Edges</h3>
<table id="edgesTable"></table>
<script>
  class MinHeap {
    constructor() {
      this.heap = [];
    }
    insert(edge) {
      this.heap.push(edge);
      this.heap.sort((a, b) => a.weight - b.weight);
    }
    extractMin() {
      return this.heap.shift();
    }
    isEmpty() {
      return this.heap.length === 0;
    }
  }

  let nodes = [];
  let edges = [];
  let mstEdges = [];
  let parent = {}, rank = {};
  let edgeQueue = new MinHeap();
  const svg = d3.select("svg");

  function generateGraph() {
    nodes = Array.from({ length: 6 }, (_, id) => ({
      id,
      x: Math.random() * 500 + 50,
      y: Math.random() * 400 + 50
    }));
    edges = [];
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        if (Math.random() > 0.5) {
          edges.push({ source: i, target: j, weight: Math.floor(Math.random() * 10) + 1 });
        }
      }
    }
    drawGraph();
    updateEdgesTable();
  }

  function drawGraph() {
    svg.selectAll("*").remove();
    svg.selectAll("line")
      .data(edges)
      .enter()
      .append("line")
      .attr("x1", d => nodes[d.source].x)
      .attr("y1", d => nodes[d.source].y)
      .attr("x2", d => nodes[d.target].x)
      .attr("y2", d => nodes[d.target].y)
      .attr("class", "edge");

    svg.selectAll("circle")
      .data(nodes)
      .enter()
      .append("circle")
      .attr("cx", d => d.x)
      .attr("cy", d => d.y)
      .attr("r", 10);

    svg.selectAll("text")
      .data(nodes)
      .enter()
      .append("text")
      .attr("x", d => d.x)
      .attr("y", d => d.y - 15)
      .text(d => d.id);
  }

  function updateEdgesTable() {
    let table = document.getElementById("edgesTable");
    table.innerHTML = "<tr><th>Источник</th><th>Цель</th><th>Вес</th></tr>" +
      edges.map(edge => `<tr><td>${edge.source}</td><td>${edge.target}</td><td>${edge.weight}</td></tr>`).join('');
  }

  function updateDisjointSetTable() {
    let table = document.getElementById("disjointSet");
    table.innerHTML = "<tr><th>Узел</th><th>Родитель</th></tr>" +
      Object.keys(parent).map(node => `<tr><td>${node}</td><td>${parent[node]}</td></tr>`).join('');
  }

  function find(i) {
    if (parent[i] === i) return i;
    return parent[i] = find(parent[i]);
  }

  function union(x, y) {
    let rootX = find(x);
    let rootY = find(y);
    if (rootX !== rootY) {
      if (rank[rootX] < rank[rootY]) {
        parent[rootX] = rootY;
      } else if (rank[rootX] > rank[rootY]) {
        parent[rootY] = rootX;
      } else {
        parent[rootY] = rootX;
        rank[rootX]++;
      }
    }
  }

  function startKruskalStepByStep() {
    edgeQueue = new MinHeap();
    edges.forEach(edge => edgeQueue.insert(edge));
    mstEdges = [];
    parent = {}; rank = {};
    nodes.forEach(node => { parent[node.id] = node.id; rank[node.id] = 0; });
    updateDisjointSetTable();
    stepKruskal();
  }

  function stepKruskal() {
    if (edgeQueue.isEmpty()) return;
    let edge = edgeQueue.extractMin();
    let root1 = find(edge.source);
    let root2 = find(edge.target);

    svg.selectAll(".current").remove();
    svg.append("line")
      .attr("x1", nodes[edge.source].x)
      .attr("y1", nodes[edge.source].y)
      .attr("x2", nodes[edge.target].x)
      .attr("y2", nodes[edge.target].y)
      .attr("class", "current");

    if (root1 !== root2) {
      mstEdges.push(edge);
      union(root1, root2);
      drawMST();
      updateDisjointSetTable();
    }
    setTimeout(stepKruskal, 1500);
  }

  function drawMST() {
    svg.selectAll(".mst").remove();
    svg.selectAll(".mst")
      .data(mstEdges)
      .enter()
      .append("line")
      .attr("x1", d => nodes[d.source].x)
      .attr("y1", d => nodes[d.source].y)
      .attr("x2", d => nodes[d.target].x)
      .attr("y2", d => nodes[d.target].y)
      .attr("class", "mst");
  }
</script>
</body>
</html>